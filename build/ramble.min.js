"use strict";

var S = {
	rambles:[],
	currentResponse:null,
	currentRamble:null,
	setCurrentResponse:function(response) {
		this.currentResponse=response;
	},
	version:"0.1.0"
};

S.Config = {
	SITE_BASE_URL: "/",
	MEDIA_URL: "/data"
	// MEDIA_URL: "http://ns.data.api.strabo.co.s3-website-us-east-1.amazonaws.com"
};

/*********************************************** 
     Begin LeafletHtmlIcon.js 
***********************************************/ 

/**
 * Plugin for adding arbitrary HTML markers to a Leaflet map
 * https://github.com/dwnoble/LeafletHtmlIcon
 * 
 * Public domain
 * 
 */

L.HtmlIcon = L.Icon.extend({
	options: {
		/*
		html: (String) (required)
		iconAnchor: (Point)
		popupAnchor: (Point)
		*/
	},

	initialize: function (options) {
		L.Util.setOptions(this, options);
	},

	createIcon: function () {
		var div = document.createElement('div');
		div.innerHTML = this.options.html;
		return div;
	},

	createShadow: function () {
		return null;
	}
});


/*********************************************** 
     Begin config.js 
***********************************************/ 

"use strict";

/*********************************************** 
     Begin icon.js 
***********************************************/ 

S.Icon = L.Icon.extend({
	options: {
	    iconUrl: '/build/images/arrow.png',
	    shadowUrl: null,
	    iconSize: new L.Point(31, 40),
	    shadowSize: null,
	    iconAnchor: new L.Point(15, 20),
	    popupAnchor: new L.Point(-3, -10)
    }
});

/*********************************************** 
     Begin marker.js 
***********************************************/ 

S.Marker = L.Marker.extend({
	currentContentIndex: 0,
	_reset: function() {
		var pos = this._map.latLngToLayerPoint(this._latlng).round();
		L.DomUtil.setPosition(this._icon, pos);
		if (this._shadow) {
			this._shadow.style.display = "none";
			//L.DomUtil.setPosition(this._shadow, pos);
		}
		this._rotate();
		this._icon.style.zIndex = pos.y;
	},
	_rotate: function() {
		if (this.options.iconAngle) {
/*
			this._icon.style.WebkitTransition = "all .15s linear";
			this._icon.style.MozTransition = "all .15s linear";
			this._icon.style.MsTransition = "all .15s linear";
			this._icon.style.OTransition = "all .15s linear";
*/
			this._icon.style.WebkitTransform += 'translate(0px, 12px)  rotate(' + this.options.iconAngle + 'deg)';
			this._icon.style.MozTransform += 'translate(0px, 12px) rotate(' + this.options.iconAngle + 'deg)';
			this._icon.style.MsTransform += 'translate(0px, 12px) rotate(' + this.options.iconAngle + 'deg)';
			this._icon.style.OTransform += 'translate(0px, 12px) rotate(' + this.options.iconAngle + 'deg)';
		}
	},
	update: function() {
		if (!this._icon) {
			return;
		}
		var pos = this._map.latLngToLayerPoint(this._latlng).round();
		this._setPos(pos);
		this._rotate();
	},
	setIconAngle: function(iconAngle) {
		this.options.iconAngle = iconAngle;
		if (this._map) {
			this._reset();
		}
	},
	getIconAngle: function() {
		return this.options.iconAngle || 0;
	},
	setLatLng: function(latlng) {
		this._latlng = latlng;
		this._reset();
		if (this._popup && this._popup.connected) {
			this._popup.setLatLng(latlng);
		}
	},
	getCount: function() {
		return this.options.count || 1;
	},
	setCount: function(count) {
		this.options.count = count;
		return this;
	},
	isClusterMarker: function() {
		return this.options.isClusterMarker || false;
	},
	moveRight: function() {
		this.currentContentIndex+=1;
		if(this.currentContentIndex > (this.children.length-1)) {
			this.currentContentIndex = this.children.length-1;
		}
		$('.ss-capture').css('display', 'none');
		var q = this.currentContentIndex;
		$('.ss-capture')[q].style.display = 'block';
	},
	moveLeft: function() {
		this.currentContentIndex-=1;
		if(this.currentContentIndex < 0) {
			this.currentContentIndex = 0;
		}
		$('.ss-capture').css('display', 'none');
		var q = this.currentContentIndex;
		$('.ss-capture')[q].style.display = 'block';
	}
});

/*********************************************** 
     Begin util.js 
***********************************************/ 

S.Util = {
	pointsToLatLngs: function(points) {
		var results = [];
		for (var x in points) {
			results.push(new L.LatLng(points[x].coords[0], points[x].coords[1]));
		}
		return results;
	},
	mediaURL: function(token) {
		return S.Config.MEDIA_URL + "/" + token + "/" + token;
	},
	createVideo: function(token) {
		var video = document.createElement('video');
		video.autoplay = false;
		if (video.canPlayType('video/webm')) {
			video.src = S.Util.mediaURL(token) + ".webm";
		} else if (video.canPlayType('video/mp4')) {
			video.src = S.Util.mediaURL(token) + ".mp4";
		} else if (video.canPlayType('video/ogg')) {
			video.src = S.Util.mediaURL(token) + ".ogg";
		} else {
			video.innerHTML = S.ERROR_CANNOT_PLAY_TYPE;
		}
		video.controls = "controls";
		video.setAttribute('class', 'strabo-popup-video');
		video.style.maxWidth = "300px";
		video.style.width = "300px";
		return video;
	},
	createPhoto: function(token) {
		var image = document.createElement('img');
		image.src = S.Util.mediaURL(token) + '.jpg';
		image.setAttribute('class', 'strabo-popup-image');
		image.style.maxWidth = "300px";
		return image;
	},
	ERROR_CANNOT_PLAY_TYPE: "Sorry, your browser cannot play HTML5 Video. Please try using <a href='http://google.com/chrome'>Google Chrome</a> for best results",
	ERROR_NOT_VIDEO: "This method can only be called on video typed rambles.",
	ERROR_NOT_PHOTO: "This method can only be called on photo typed rambles."
};
if (!Array.prototype.forEach) {
	Array.prototype.forEach = function(fn, scope) {
		for (var i = 0, len = this.length; i < len; ++i) {
			fn.call(scope || this, this[i], i, this);
		}
	}
}

/*********************************************** 
     Begin popup.js 
***********************************************/ 

"use strict";
S.Popup = L.Popup.extend({
	connected: true,
	options: {
		minWidth: 50,
		maxWidth: 360,
		maxHeight: null,
		autoPan: true,
		closeButton: true,
		offset: new L.Point(0, 6),
		autoPanPadding: new L.Point(5, 5),
		className: ''
	},
	_initLayout: function() {
		var prefix = 'strabo-popup',
			container = this._container = L.DomUtil.create('div', prefix + ' ' + this.options.className + ' strabo-zoom-animated'),
			closeButton;
		if (this.options.closeButton) {
			closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			L.DomEvent.addListener(closeButton, 'click', this._onCloseButtonClick, this);
		}
		var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
		L.DomEvent.disableClickPropagation(wrapper);
		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);
		L.DomEvent.addListener(this._contentNode, 'mousewheel', L.DomEvent.stopPropagation);
		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},
	_update: function() {
		if (!this._map) {
			return;
		}
		this._container.style.visibility = 'hidden';
		this._updateLayout();
		this._updatePosition();
		this._container.style.visibility = '';
		this._adjustPan();
	}
});
S.Marker.include({
	openPopup: function() {
		if (this._popup && this._map) {
			this._popup.setLatLng(this._latlng);
			this._map.openPopup(this._popup);
		}
		return this;
	},
	closePopup: function() {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},
	bindPopup: function(content, options) {
		var anchor = this.options.icon.options.popupAnchor || new L.Point(0, 0);
		if (options && options.offset) {
			anchor = anchor.add(options.offset);
		}
		options = L.Util.extend({
			offset: anchor
		}, options);
		if (!this._popup) {
			this.on('click', this.openPopup, this);
		}
		this._popup = new S.Popup(options, this).setContent(content);
		return this;
	},
	unbindPopup: function() {
		if (this._popup) {
			this._popup = null;
			this.off('click', this.openPopup);
		}
		return this;
	}
});

/*********************************************** 
     Begin ramble.js 
***********************************************/ 

S.Ramble = function(map, rambleID, opts) {
	this.fireEvent("constructed", {
		map: map,
		id: rambleID
	});
	this._listeners = {};
	if (!map) {
		this._error("Map parameter cannot be undefined.");
	}
	if (!rambleID) {
		this._error("rambleID parameter cannot be undefined.");
	}
	this.id = rambleID;
	//Control Parameters
	this.options = opts || {};
	this.options.clustering = opts.clustering || false;
	this.options.showRoutes = opts.showRoutes || false;
	//Map Properties
	this.map = map;
	this.MAP_WIDTH = map.getSize().x;
	this.MAP_HEIGHT = map.getSize().y;
	//Media/Geodata Properties
	this.videoLoaded = false;
	this.currentPoint = 0;
	this.title = "";
	this.latitude = 0;
	this.longitude = 0;
	this.heading = 0;
	this.points = [];
	this.description = "";
	this.token = "";
	this.createdAt = null;
	this.uploadedAt = null;
	this.type = null;
	this.video = null;
	this.photo = null;
	this.start = null;
	this.marker = null;
	this.route = null;
	// Talk to the Server to Retrieve Geo-Data
	this._pull();
};
S.Ramble.prototype._pull = function() {
	this.fireEvent("geodatapull");
	//Process Response Through JSONP Method
	S.rambles[this.id] = this;
	var myscript = document.createElement('script');
	myscript.setAttribute('src', S.Config.MEDIA_URL + "/" + this.id + "/" + this.id + ".js");
	document.body.appendChild(myscript);
};
S.Ramble.prototype._processResponse = function(response) {
	var r = this;
	//response = response.response;
	r.title = response.title;
	r.latitude = parseFloat(response.coords[0]);
	r.longitude = parseFloat(response.coords[1]);
	r.heading = parseFloat(response.heading);
	r.points = response.points;
	r.description = response.description;
	r.token = response.token;
	r.createdAt = response.created_at;
	r.uploadedAt = response.uploaded_at;
	r.type = response.media_type;
	r.start = new L.LatLng(r.latitude, r.longitude);
	r._latLngs = S.Util.pointsToLatLngs(r.points);
	r._icon = new S.Icon();
	r.marker = new S.Marker(r.start, {
		icon: r._icon,
		count: 1
	});
	r.marker.setIconAngle(Math.round((r.heading)));
	if (r._latLngs.length > 1) {
		r.polyline = new L.Polyline(r._latLngs, {
			color: "#DB6C4D"
		});
	}
	r.show();
	if (r.type === "video") {
		r._initializeVideoPopup();
		r.video.addEventListener('timeupdate', function() {
			r._updateMap();
			r.fireEvent("timeupdate");
		});
		r.video.addEventListener("ended", function() {
			r.reset();
			r.fireEvent("ended");
		});
		r.video.addEventListener("seeking", function() {
			r._syncVideo();
			r.fireEvent("seeking");
		});
		r.video.addEventListener("seeked", function() {
			r._syncVideo();
			r.fireEvent("seeked");
		});
		r.video.addEventListener("play", function() {
			r.fireEvent("play");
		});
		r.video.addEventListener("pause", function() {
			r.fireEvent("pause");
		});
	} else if (r.type === "image") {
		r._initializePhotoPopup();
	}
	r.marker.on("click", function() {
		r.marker.openPopup();
		r.showWithRoute();
	});
	r.fireEvent('geodatapulled');
};
S.Ramble.prototype.show = function() {
	if (this.options.showRoutes && this.polyline && !this.map.hasLayer(this.polyline)) {
		this.map.addLayer(this.polyline);
	}
	if (this.marker && !this.map.hasLayer(this.marker)) {
		this.map.addLayer(this.marker);
	}
};
S.Ramble.prototype.showWithRoute = function() {
	if (this.polyline && !this.map.hasLayer(this.polyline)) {
		this.map.addLayer(this.polyline);
	}
	if (this.marker && !this.map.hasLayer(this.marker)) {
		this.map.addLayer(this.marker);
	}
};
S.Ramble.prototype.hide = function() {
	if (this.polyline) this.map.removeLayer(this.polyline);
	this.map.removeLayer(this.marker);
};
S.Ramble.prototype._initializeVideoPopup = function() {
	if (this.type == "video") {
		var container = document.createElement('div');
		var videoTitle = document.createElement('div');
		videoTitle.setAttribute('class', 'video-popup-title');
		videoTitle.innerHTML = this.title;
		this.video = S.Util.createVideo(this.token);
		this.video.width = "300"; /* 		this.video.style.width = (this.MAP_WIDTH / 4) + "px"; */
		container.appendChild(videoTitle);
		container.appendChild(this.video);
		this.marker.bindPopup(container);
	} else this._error(S.Util.ERROR_NOT_VIDEO);
};
S.Ramble.prototype._initializePhotoPopup = function() {
	if (this.type == "image") {
		var container = document.createElement('div');
		var photoTitle = document.createElement('div');
		photoTitle.setAttribute('class', 'photo-popup-title');
		photoTitle.innerHTML = this.title;
		this.photo = S.Util.createPhoto(this.token);
		this.photo.width = "300"; /* 		this.photo.style.width = (this.MAP_WIDTH / 4) + "px"; */
		container.appendChild(photoTitle);
		container.appendChild(this.photo);
		this.marker.bindPopup(container);
	} else this._error(S.Util.ERROR_NOT_PHOTO);
}
S.Ramble.prototype._updateMap = function() {
	if (this.type == "video" && this.points) {
		var pointTime;
		var cTime = this.video.currentTime;
		if (cTime > this.video.duration) { // If video is done.
			this._error('wtf');
			this.currentPoint = 0;
		} else {
			if (this.currentPoint >= this.points.length) {
				this.currentPoint = this.points.length - 1;
			}
			pointTime = this.points[this.currentPoint].timestamp;
			while (cTime > pointTime && this.currentPoint < this.points.length - 1) {
				this.currentPoint++;
				pointTime = this.points[this.currentPoint].timestamp;
			}
			this._setCurrentPoint(this.currentPoint);
		}
	} else this._error(S.Util.ERROR_NOT_VIDEO);
};
S.Ramble.prototype._syncVideo = function() {
	if (this.video) {
		this._getPointByTime(this.video.currentTime);
		this._setCurrentPoint(this.currentPoint);
	} else this._error(S.Util.ERROR_NOT_VIDEO);
};
S.Ramble.prototype.reset = function() {
	if (this.video) {
		this.setTime(0);
		this.fireEvent("reset");
	} else this._error(S.Util.ERROR_NOT_VIDEO);
};
S.Ramble.prototype._getPointByTime = function(timestamp, head, tail) {
	head = head || 0;
	tail = tail || this.points.length;
	var midpoint = parseInt((tail + head) / 2, 10);
	var length = tail - head;
	if (length <= 1 || timestamp == this.points[midpoint].timestamp) {
		this.currentPoint = midpoint;
	} else if (timestamp > this.points[midpoint].timestamp) {
		this._getPointByTime(timestamp, midpoint, tail);
	} else if (timestamp < this.points[midpoint].timestamp) {
		this._getPointByTime(timestamp, head, midpoint);
	}
};
S.Ramble.prototype._setCurrentPoint = function(currentPoint) {
	if (this.video && this.marker) {
		this.currentPoint = currentPoint;
		var currentAngle = this.marker.getIconAngle();
		var nextAngle = Math.round(this.points[this.currentPoint].heading);
		var delta = (nextAngle - currentAngle);
		if (delta > 180) {
			delta -= 360;
		}
		this.marker.setIconAngle(currentAngle + delta);
		this.marker.setLatLng(new L.LatLng(this.points[this.currentPoint].coords[0], this.points[this.currentPoint].coords[1]));
	} else this._error(S.Util.ERROR_NOT_VIDEO);
};
S.Ramble.prototype.getTime = function() {
	if (this.video) {
		return this.video.currentTime;
	} else this._error(S.Util.ERROR_NOT_VIDEO);
};
S.Ramble.prototype.setTime = function(newTime) {
	if (this.video) {
		if (newTime < 0 || newTime >= this.video.duration) this._error("Suggested time is out of bounds.");
		this.video.currentTime = 0;
		this._getPointByTime(newTime);
		this._setCurrentPoint(this.currentPoint);
		return this;
	} else this._error(S.Util.ERROR_NOT_VIDEO);
};
S.Ramble.prototype.getLatLng = function() {
	return this.start;
};
S.Ramble.prototype.play = function() {
	if (this.video) {
		this.video.play();
	} else this._error(S.Util.ERROR_NOT_VIDEO);
};
S.Ramble.prototype.pause = function() {
	if (this.video) {
		this.video.pause();
	} else this._error(S.Util.ERROR_NOT_VIDEO);
};
S.Ramble.prototype.playPause = function() {
	if (this.video) {
		if (this.video.paused) {
			this.play();
		} else {
			this.pause();
		}
	} else this._error(S.Util.ERROR_NOT_VIDEO);
};
S.Ramble.prototype.addEventListener = function(type, fn, context) {
	var events = this._events = this._events || {};
	events[type] = events[type] || [];
	events[type].push({
		action: fn,
		context: context || this
	});
	return this;
};
S.Ramble.prototype.hasEventListeners = function(type) {
	var k = '_events';
	return (k in this) && (type in this[k]) && (this[k][type].length > 0);
};
S.Ramble.prototype.removeEventListener = function(type, fn, context) {
	if (!this.hasEventListeners(type)) {
		return this;
	}
	for (var i = 0, events = this._events, len = events[type].length; i < len; i++) {
		if ((events[type][i].action === fn) && (!context || (events[type][i].context === context))) {
			events[type].splice(i, 1);
			return this;
		}
	}
	return this;
};
S.Ramble.prototype.getType = function() {
	return this.type;
};
S.Ramble.prototype.fireEvent = function(type, data) {
	if (!this.hasEventListeners(type)) {
		return this;
	}
	var event = L.Util.extend({
		type: type,
		target: this
	}, data);
	var listeners = this._events[type].slice();
	for (var i = 0, len = listeners.length; i < len; i++) {
		listeners[i].action.call(listeners[i].context || this, event);
	}
	return this;
};
S.Ramble.prototype._error = function(parameter) {
	var msg = "Ramble-" + this.id + ": " + parameter;
	this.fireEvent("error", {
		"text": parameter
	});
	if (console) console.error(msg);
};

/*********************************************** 
     Begin ramblelist.js 
***********************************************/ 

S.RambleList = function(map, ids, options) {
	this.options = options || {};
	this.options.clustering = options.clustering || false;
	this.options.showRoutes = options.showRoutes || false;
	this.map = map;
	this.ids = ids;
	this.size = ids.length;
	this.completed = 0;
	this.rambles = [];
	var theRambleList = this,
		clustering = this.options.clustering || false,
		showRoutes = this.options.showRoutes || false;
	for (var x in ids) {
		var aRamble = new S.Ramble(map, ids[x], {
			addToMap: false,
			list: theRambleList,
			clustering: clustering,
			showRoutes: showRoutes
		});
		aRamble.addEventListener("geodatapulled", function() {
			this.completed += 1;
			if(this.completed == this.size) {
				this.fireEvent("geodatapulled", {
					size:this.size
				});
			}
		}, theRambleList);
		this.rambles.push(aRamble);
	}
	if (this.options.clustering) {
		map.on("zoomend", function() {
			theRambleList.checkMarkers();
		});
		for (x in this.rambles) {
			this.rambles[x].addEventListener("geodatapulled", function() {
				theRambleList.checkMarkers();
			});
		}
	}
	this.fireEvent("constructed",this);
};
S.RambleList.prototype.show = function() {
	for (var x in this.rambles) {
		this.rambles[x].show();
	}
	this.fireEvent("show",this);
};
S.RambleList.prototype.hide = function() {
	for (var x in this.rambles) {
		this.rambles[x].hide();
	}
	this.fireEvent("hide",this);
};
// Clustering Algorithm
S.RambleList.prototype.checkMarkers = function() {
	for (var x in this.displayMarkers) {
		this.map.removeLayer(this.displayMarkers[x]);
	}
	this.displayMarkers = [];
	// Will wait until all markers in the RambleList have been creat
	var shouldProceed = true;
	for (x in this.rambles) {
		if (!this.rambles[x].marker) {
			shouldProceed = false;
		}
	}
	if (shouldProceed) {
		for (x in this.rambles) {
			var tmp = this.rambles[x].marker;
			this.map.removeLayer(tmp);
			var shouldCluster = false;
			for (var y in this.displayMarkers) {
				var tmp2 = this.displayMarkers[y];
				var yMapSize = this.map.getBounds().getNorthEast().lat - this.map.getBounds().getSouthWest().lat;
				var xMapSize = this.map.getBounds().getNorthEast().lng - this.map.getBounds().getSouthWest().lng;
				var yMapDist = Math.abs(tmp.getLatLng().lat - tmp2.getLatLng().lat);
				var xMapDist = Math.abs(tmp.getLatLng().lng - tmp2.getLatLng().lng);
				var mapSize = Math.sqrt(Math.pow(xMapSize, 2) + Math.pow(yMapSize, 2));
				var mapDist = Math.sqrt(Math.pow(xMapDist, 2) + Math.pow(yMapDist, 2));
				if (mapDist < (mapSize * 0.05)) {
					shouldCluster = true;
					var string = "Merging a ";
					if (tmp.isClusterMarker()) {
						string += "clustermarker ";
					} else {
						string += "non-clustermarker ";
					}
					string += "with a "
					if (tmp2.isClusterMarker()) {
						string += "clustermarker";
					} else {
						string += "non-clustermarker";
					}
					string += ". The current count for the clustermarker is " + (tmp.getCount() + tmp2.getCount());
					//console.log(string);
					this.displayMarkers[y] = new S.Marker(new L.LatLng((tmp.getLatLng().lat + tmp2.getLatLng().lat) / 2, (tmp.getLatLng().lng + tmp2.getLatLng().lng) / 2), {
						icon: new L.HtmlIcon({
							html: "<div class='strabo-count-marker'>" + (tmp.getCount() + tmp2.getCount()) + "</div>"
						}),
						count: tmp.getCount() + tmp2.getCount(),
						isClusterMarker: true
					});
					this.displayMarkers[y].generatedMarker = true;
					this.displayMarkers[y].children = [];
					this.displayMarkers[y].children = this.displayMarkers[y].children.concat(this.pullChildren(tmp));
					this.displayMarkers[y].children = this.displayMarkers[y].children.concat(this.pullChildren(tmp2));
					if (this.map.getZoom() >= this.map.getMaxZoom()) {
						var popupContent = '<div class="seek-left unselectable"></div><div class="seek-content">';
						for (var z in this.displayMarkers[y].children) {
							//console.log(this.displayMarkers[y].children[z].isClusterMarker());
							popupContent += '<div class="ss-capture unselectable">';
							popupContent += this.displayMarkers[y].children[z]._popup._content.innerHTML;
							popupContent += '</div>';
						}
						popupContent += '</div><div class="seek-right unselectable"></div>';
						this.displayMarkers[y].bindPopup(popupContent);
						this.displayMarkers[y].on("click", function() {
							//console.log("Click Detected. Expanding " + this.children.length + " child nodes.");
							this.openPopup(this._popup);
							$('.ss-capture').css('display', 'none');
							var q = this.currentContentIndex;
							$('.ss-capture')[q].style.display = 'block';
							var pq = this;
							$('.seek-right').click(function() {
								pq.moveRight();
							});
							$('.seek-left').click(function() {
								pq.moveLeft();
							});
							$('.strabo-popup-close-button').css('z-index','150');
						});
					} else {
						this.displayMarkers[y].on("click", function() {
							map.setView(this.getLatLng(), map.getZoom());
							map.zoomIn();
						});
					}
				} else {}
			}
			if (!shouldCluster) {
				//console.log("Forming a new cluster.");
				this.displayMarkers.push(tmp);
			}
		}
	}
	for (x in this.displayMarkers) {
		this.map.addLayer(this.displayMarkers[x]);
	}
	this.fireEvent("cluster",this);
};
// Method for recursively grabbing child elements.
S.RambleList.prototype.pullChildren = function(marker) {
	var result = [];
	if (marker.children) {
		for (var x in marker.children) {
			result = result.concat(this.pullChildren(marker.children[x]));
		}
	} else {
		result.push(marker);
	}
	return result;
};

S.RambleList.prototype.findRambleByToken = function(token) {
	var result;
	for (var x in this.rambles) {
		if (this.rambles[x].token == token) {
			result = this.rambles[x];
		}
	}
	return result;
};
S.RambleList.prototype.addRamble = function(token) {
	this.rambles.push(new S.Ramble(this.map, token));
};
S.RambleList.prototype.addEventListener = function(type, fn, context) {
	var events = this._events = this._events || {};
	events[type] = events[type] || [];
	events[type].push({
		action: fn,
		context: context || this
	});
	return this;
};
S.RambleList.prototype.hasEventListeners = function(type) {
	var k = '_events';
	return (k in this) && (type in this[k]) && (this[k][type].length > 0);
};
S.RambleList.prototype.removeEventListener = function(type, fn, context) {
	if (!this.hasEventListeners(type)) {
		return this;
	}
	for (var i = 0, events = this._events, len = events[type].length; i < len; i++) {
		if ((events[type][i].action === fn) && (!context || (events[type][i].context === context))) {
			events[type].splice(i, 1);
			return this;
		}
	}
	return this;
};
S.RambleList.prototype.fireEvent = function(type, data) {
	if (!this.hasEventListeners(type)) {
		return this;
	}
	var event = L.Util.extend({
		type: type,
		target: this
	}, data);
	var listeners = this._events[type].slice();
	for (var i = 0, len = listeners.length; i < len; i++) {
		listeners[i].action.call(listeners[i].context || this, event);
	}
	return this;
};
S.RambleList.prototype._error = function(parameter) {
	var msg = "RambleList-" + this.id + ": " + parameter;
	this.fireEvent("error", {
		"text": parameter
	});
	if (console) console.error(msg);
};